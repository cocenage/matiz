{
  "version": 3,
  "sources": ["../../filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js"],
  "sourcesContent": ["/*!\r\n * FilePondPluginFileValidateType 1.2.8\r\n * Licensed under MIT, https://opensource.org/licenses/MIT/\r\n * Please visit https://pqina.nl/filepond/ for details.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nconst plugin = ({ addFilter, utils }) => {\r\n  // get quick reference to Type utils\r\n  const {\r\n    Type,\r\n    isString,\r\n    replaceInString,\r\n    guesstimateMimeType,\r\n    getExtensionFromFilename,\r\n    getFilenameFromURL\r\n  } = utils;\r\n\r\n  const mimeTypeMatchesWildCard = (mimeType, wildcard) => {\r\n    const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\r\n    const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\r\n    return mimeTypeGroup === wildcardGroup;\r\n  };\r\n\r\n  const isValidMimeType = (acceptedTypes, userInputType) =>\r\n    acceptedTypes.some(acceptedType => {\r\n      // accepted is wildcard mime type\r\n      if (/\\*$/.test(acceptedType)) {\r\n        return mimeTypeMatchesWildCard(userInputType, acceptedType);\r\n      }\r\n\r\n      // is normal mime type\r\n      return acceptedType === userInputType;\r\n    });\r\n\r\n  const getItemType = item => {\r\n    // if the item is a url we guess the mime type by the extension\r\n    let type = '';\r\n    if (isString(item)) {\r\n      const filename = getFilenameFromURL(item);\r\n      const extension = getExtensionFromFilename(filename);\r\n      if (extension) {\r\n        type = guesstimateMimeType(extension);\r\n      }\r\n    } else {\r\n      type = item.type;\r\n    }\r\n\r\n    return type;\r\n  };\r\n\r\n  const validateFile = (item, acceptedFileTypes, typeDetector) => {\r\n    // no types defined, everything is allowed \\o/\r\n    if (acceptedFileTypes.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // gets the item type\r\n    const type = getItemType(item);\r\n\r\n    // no type detector, test now\r\n    if (!typeDetector) {\r\n      return isValidMimeType(acceptedFileTypes, type);\r\n    }\r\n\r\n    // use type detector\r\n    return new Promise((resolve, reject) => {\r\n      typeDetector(item, type)\r\n        .then(detectedType => {\r\n          if (isValidMimeType(acceptedFileTypes, detectedType)) {\r\n            resolve();\r\n          } else {\r\n            reject();\r\n          }\r\n        })\r\n        .catch(reject);\r\n    });\r\n  };\r\n\r\n  const applyMimeTypeMap = map => acceptedFileType =>\r\n    map[acceptedFileType] === null\r\n      ? false\r\n      : map[acceptedFileType] || acceptedFileType;\r\n\r\n  // setup attribute mapping for accept\r\n  addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', map =>\r\n    Object.assign(map, {\r\n      accept: 'acceptedFileTypes'\r\n    })\r\n  );\r\n\r\n  // filtering if an item is allowed in hopper\r\n  addFilter('ALLOW_HOPPER_ITEM', (file, { query }) => {\r\n    // if we are not doing file type validation exit\r\n    if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\r\n      return true;\r\n    }\r\n\r\n    // we validate the file against the accepted file types\r\n    return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\r\n  });\r\n\r\n  // called for each file that is loaded\r\n  // right before it is set to the item state\r\n  // should return a promise\r\n  addFilter(\r\n    'LOAD_FILE',\r\n    (file, { query }) =>\r\n      new Promise((resolve, reject) => {\r\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\r\n          resolve(file);\r\n          return;\r\n        }\r\n\r\n        const acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\r\n\r\n        // custom type detector method\r\n        const typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\r\n\r\n        // if invalid, exit here\r\n        const validationResult = validateFile(\r\n          file,\r\n          acceptedFileTypes,\r\n          typeDetector\r\n        );\r\n\r\n        const handleRejection = () => {\r\n          const acceptedFileTypesMapped = acceptedFileTypes\r\n            .map(\r\n              applyMimeTypeMap(\r\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\r\n              )\r\n            )\r\n            .filter(label => label !== false);\r\n\r\n          const acceptedFileTypesMapped_unique = acceptedFileTypesMapped.filter(\r\n            function(item, index) {\r\n              return acceptedFileTypesMapped.indexOf(item) === index;\r\n            }\r\n          );\r\n\r\n          reject({\r\n            status: {\r\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\r\n              sub: replaceInString(\r\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\r\n                {\r\n                  allTypes: acceptedFileTypesMapped_unique.join(', '),\r\n                  allButLastType: acceptedFileTypesMapped_unique\r\n                    .slice(0, -1)\r\n                    .join(', '),\r\n                  lastType:\r\n                    acceptedFileTypesMapped_unique[\r\n                      acceptedFileTypesMapped.length - 1\r\n                    ]\r\n                }\r\n              )\r\n            }\r\n          });\r\n        };\r\n\r\n        // has returned new filename immidiately\r\n        if (typeof validationResult === 'boolean') {\r\n          if (!validationResult) {\r\n            return handleRejection();\r\n          }\r\n          return resolve(file);\r\n        }\r\n\r\n        // is promise\r\n        validationResult\r\n          .then(() => {\r\n            resolve(file);\r\n          })\r\n          .catch(handleRejection);\r\n      })\r\n  );\r\n\r\n  // expose plugin\r\n  return {\r\n    // default options\r\n    options: {\r\n      // Enable or disable file type validation\r\n      allowFileTypeValidation: [true, Type.BOOLEAN],\r\n\r\n      // What file types to accept\r\n      acceptedFileTypes: [[], Type.ARRAY],\r\n      // - must be comma separated\r\n      // - mime types: image/png, image/jpeg, image/gif\r\n      // - extensions: .png, .jpg, .jpeg ( not enabled yet )\r\n      // - wildcards: image/*\r\n\r\n      // label to show when a type is not allowed\r\n      labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\r\n\r\n      // nicer label\r\n      fileValidateTypeLabelExpectedTypes: [\r\n        'Expects {allButLastType} or {lastType}',\r\n        Type.STRING\r\n      ],\r\n\r\n      // map mime types to extensions\r\n      fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\r\n\r\n      // Custom function to detect type of file\r\n      fileValidateTypeDetectType: [null, Type.FUNCTION]\r\n    }\r\n  };\r\n};\r\n\r\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\r\nconst isBrowser =\r\n  typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\nif (isBrowser) {\r\n  document.dispatchEvent(\r\n    new CustomEvent('FilePond:pluginloaded', { detail: plugin })\r\n  );\r\n}\r\n\r\nexport default plugin;\r\n"],
  "mappings": "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",
  "names": []
}
